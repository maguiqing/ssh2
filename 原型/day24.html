<html>
<head>
  <title>Evernote Export</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/305825 (zh-CN, DDL); Windows/6.1.7601 Service Pack 1 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 12pt;
    }
  </style>
</head>
<body>
<a name="1342"/>

<div>
<span><div><br/></div><div><br/></div><div>梳理知识点</div><div style="box-sizing: border-box; padding: 8px; font-size: 12px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="background-color: rgb(251, 250, 248); font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">对象创建的几种方法 及  优缺点 ： </span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">1、obj = new Object()    obj = {  }</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">2、工厂模式创建多个同类对象             类  对象</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">function animal(name){</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">    var obj = new Object();</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">    obj.name = name</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">    obj.eat = function(){...}</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">    return obj</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">}</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">var obj = animal(&quot;大白&quot;) </span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">3、构造函数</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">function Animal(){</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">    //构造函数中的this指向的是构造函数new出来的对象</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">    this.name = &quot;xiaobai&quot;</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">    this.eat = function(){...}</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">}</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">var animal = new Animal();   实例化一个对象 （创建一个对象）</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">var a2 = new Animal()</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">缺点 ： 同类对象的方法会被重复创建 </span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">4、原型  </span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">function Animal(){</span></div><div><br/></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">}</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">Animal.prototype.name = &quot;xb&quot;</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">Animal.prototype.eat = function(){</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">    this //指向构造函数new出来的对象</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">}</span></div><div><br/></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">var animal = new Animal()</span></div><div><span style="font-size: 12pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">var animal2 = new Animal()</span></div><div><span style="font-size: 12pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco;">5、混合</span></div><div><br/></div></div><div><br/></div><div>2、原型对象</div><div style="box-sizing: border-box; padding: 8px; font-size: 12px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="background-color: rgb(251, 250, 248); font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">所有的构造函数都有一个prototype属性，这个属性叫做原型对象       构造函数.prototype</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">所有的构造函数new出来的对象也都有一个prototype对象，但是 实现   对象.__proto__</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><img src="day24_files/Image.png" type="image/png" data-filename="" style="font-family: Monaco; color: rgb(51, 51, 51);" width="623"/></span></div><div><font style="font-size: 14px;"><span style="background-color: rgb(251, 250, 248); font-size: 14px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; line-height: 23px;">原型方法和普通方法的区别 ： </span></font></div><div><font style="font-size: 14px;"><span style="background-color: rgb(251, 250, 248); font-size: 14px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; line-height: 23px;">    原型方法可以复用   普通方法不可以复用</span></font></div><div><font style="font-size: 14px;"><span style="background-color: rgb(251, 250, 248); font-size: 14px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; line-height: 23px;">    原型方法优先级低   普通方法优先级高     (class  和 style)</span></font></div><div><br/></div><div><span style="font-size: 14px; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; line-height: 23px;">原型属性和实例属性优先级 ： </span></div><div><span style="font-size: 14px; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; line-height: 23px;">    原型属性的优先级低</span></div></div><div><br/></div><div>3、原型链</div><div style="box-sizing: border-box; padding: 8px; font-size: 12px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="background-color: rgb(251, 250, 248); font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">实例对象和原型之间的链接  叫做原型链  __proto__</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><img src="day24_files/Image [1].png" type="image/png" data-filename="" style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);" width="771"/></span></div></div><div><br/></div><div>4、原型模式的执行流程</div><div style="box-sizing: border-box; padding: 8px; font-size: 12px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="background-color: rgb(251, 250, 248); font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">1、首先在实例中查找，如果找到就返回  </span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">2、如果在实例中没有查找到  就去原型中查找 ，如果查找到就返回  </span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">3、如果在原型中没有找到 去Object的原型上查找，如果找到就返回  如果没找到 就返回undefined</span></div><div><br/></div></div><div><br/></div><div>练习 ：</div><div style="box-sizing: border-box; padding: 8px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div style="font-size: 12px;"><span style="background-color: rgb(251, 250, 248); font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">在Array的原型上实现一个数组去重的方法</span></div><div><font style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; color: rgb(51, 51, 51);">Array.prototype.norepeat = function(){</font></div><div><font color="#333333" face="Monaco, Menlo, Consolas, Courier New, monospace"><span>    var brr = [];</span><br/></font></div><div><font style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; color: rgb(51, 51, 51);"><span>    for( var i = 0 ; i &lt; this.length ; i++ ){</span></font></div><div><font style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; color: rgb(51, 51, 51);"><span>    <span>    if( brr.indexOf(this[i]) == -1 ){</span></span></font></div><div><font style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; color: rgb(51, 51, 51);"><span><span>    <span>    <span>    brr.push( this[i] );</span></span></span><br/></span></font></div><div><font color="#333333" face="Monaco, Menlo, Consolas, Courier New, monospace"><span><span><span>    <span>    </span></span>}</span><br/></span></font></div><div><font color="#333333" face="Monaco, Menlo, Consolas, Courier New, monospace"><span><span><span>    </span>}</span><br/></span></font></div><div><font color="#333333" face="Monaco, Menlo, Consolas, Courier New, monospace"><span><span>    return brr;</span><br/></span></font></div><div><font color="#333333" face="Monaco, Menlo, Consolas, Courier New, monospace">}</font></div><div style="font-size: 12px;"><span style="background-color: rgb(251, 250, 248); font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">在String的原型上实现一个去掉字符串两点空白的方法  trim() </span></div><div style="font-size: 12px;"><span style="background-color: rgb(251, 250, 248); font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">String.prototype.trim = function(){</span></div><div style="font-size: 12px;"><span style="background-color: rgb(251, 250, 248); font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span>    return this.replace( /(^\s+)|(\s+$)/g , &quot;&quot;  );</span><br/></span></div><div style="font-size: 12px;"><span style="background-color: rgb(251, 250, 248); font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">}</span></div><div style="font-size: 12px;"><span style="background-color: rgb(251, 250, 248); font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><br/></span></div></div><div><br/></div><div>5、原型中的关键字</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;-en-codeblock:true;"><div><span style="font-family: Monaco; color: rgb(51, 51, 51);"><font style="font-size: 12pt;">测试某个对象是否属于某个类的方法 isPrototypeOf()</font></span></div><div><span style="font-family: Monaco; color: rgb(51, 51, 51);"><font style="font-size: 12pt;">语法： 构造函数.prototype.isPrototypeOf(对象):判断一个对象是否指向了该构造函数的原型对象，可以使用isPrototypeOf()方法来测试     结果为boolean类型  同  instanceof</font></span></div><div><span style="font-family: Monaco; color: rgb(51, 51, 51);"><font style="font-size: 12pt;"><br/></font></span></div><div><span style="font-family: Monaco; color: rgb(51, 51, 51);"><font style="font-size: 12pt;">delete ：删除实例属性</font></span></div><div><span style="font-family: Monaco; color: rgb(51, 51, 51);"><font style="font-size: 12pt;">语法 ：  delete  对象.实例属性</font></span></div><div><span style="font-family: Monaco; color: rgb(51, 51, 51);"><font style="font-size: 12pt;"><br/></font></span></div><div><span style="font-family: Monaco; color: rgb(51, 51, 51);"><font style="font-size: 12pt;">hasOwnProperty() 是否包含该实例属性,包含返回true，否则返回false</font></span></div><div><span style="font-family: Monaco; color: rgb(51, 51, 51);"><font style="font-size: 12pt;">语法： 实例对象.hasOwnProperty(&quot;实例属性&quot;)</font></span></div><div><span style="font-family: Monaco; color: rgb(51, 51, 51);"><font style="font-size: 12pt;"><br/></font></span></div><div><span style="font-family: Monaco; color: rgb(51, 51, 51);"><font style="font-size: 12pt;">in 是否存在该属性（原型或实例中）</font></span></div><div><span style="font-family: Monaco; color: rgb(51, 51, 51);"><font style="font-size: 12pt;">语法： &quot;属性&quot; in  对象实例</font></span></div></div><div><br/></div><div>6、面向对象的三大特性</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;-en-codeblock:true;"><div><font style="font-size: 12pt;">封装 ： 屏蔽内部细节  </font></div><div><font style="font-size: 12pt;">继承 ： 子类继承父类 （继承父类所有的属性和功能）</font></div><div><font style="font-size: 12pt;">多态（js中没有）</font></div></div><div><br/></div><div>7、继承方式一 --  通过改变父类的执行环境</div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;-en-codeblock:true;"><div><font style="font-size: 12pt;">子类中有一个特殊属性 指向父类 ， 通过子类的属性  调用父类</font></div></div><div><br/></div><div>8、继承方式二、三</div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;-en-codeblock:true;"><div><font style="font-size: 12pt;">call()  和  apply() 的继承 ： 只能继承实例属性和实例方法</font></div><div><font style="font-size: 12pt;">区别 ： </font></div><div><font style="font-size: 12pt;">call的第二个参数的个数不固定  </font></div><div><font style="font-size: 12pt;">apply的第二个参数是一个数组  可以通过arguments代替这个数组，提高编程效率</font></div><div><br/></div></div><div><br/></div><div>9、继承方式 四</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;-en-codeblock:true;"><div><font style="font-size: 12pt;">原型继承 ： </font></div><div><font style="font-size: 12pt;"> 子类.prototype = new 父类()    </font></div><div><font style="font-size: 12pt;">缺点 ：如果父类的实例属性值 不固定，原型继承 继承实例属性值时  值无法更改  </font></div></div><div><br/></div><div>10 、 混合继承<br/></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;-en-codeblock:true;"><div><font style="font-size: 12pt;">通过 call或apply方式继承 实例属性</font></div><div><font style="font-size: 12pt;">通过 原型方式继承原型方法  </font></div></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div></span>
</div></body></html> 